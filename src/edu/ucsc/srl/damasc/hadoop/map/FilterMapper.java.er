package edu.ucsc.srl.damasc.hadoop.map;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.conf.Configuration;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.filecache.DistributedCache;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.mapred.JobConf;
import org.apache.hadoop.mapreduce.Mapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import edu.ucsc.srl.damasc.hadoop.Utils;
import edu.ucsc.srl.damasc.hadoop.Utils.FilterCounters;
import edu.ucsc.srl.damasc.hadoop.io.ArraySpec;
import edu.ucsc.srl.damasc.hadoop.io.DataIterator;
import edu.ucsc.srl.damasc.hadoop.io.IntArrayWritable;
import edu.ucsc.srl.damasc.hadoop.io.MultiVarData;

//import java.lang.Thread;
//import org.apache.hadoop.io.IntWritable;

/**GroupID
 * Dummy mapper, just passed data through with a dummy key.
 * This is used for testing purposes
 */
public class FilterMapper extends Mapper<ArraySpec, MultiVarData, ArraySpec, IntArrayWritable> {

  private static int DATATYPESIZE = 4;
  //private Path[] localArchives = new Path[0];
  //private Path[] localFiles = new Path[0];
  private static final Log LOG = LogFactory.getLog(FilterMapper.class);

 /**
 * Reduces values for a given key
 * @param key ArraySpec representing the given Array being passed in
 * @param value an Array to process that corresponds to the given key 
 * @param context the Context object for the currently executing job
 */
  public void map(ArraySpec key, MultiVarData inMVD, Context context)
                  throws IOException, InterruptedException {

    String taskID = context.getTaskAttemptID().toString();
    //System.out.println("taskID: " + taskID);
    String[] splitTaskID = taskID.split("_");
    Configuration conf = context.getConfiguration();

    /*
    try{ 
      Path[] localFiles = DistributedCache.getLocalCacheFiles(context.getConfiguration());
      if (localFiles != null) { 
        LOG.info("JB5, loading coordinate variable from file: " + localFiles[0].toString());

      }

      //Path coordVarPath = new Path(key.getFileName() + "." + Utils.getCoordinateVariableName(conf));
      //LOG.info("JB6, hoping the coord var data is in file: " + coordVarPath.toString());

      FileSystem fs = FileSystem.get(conf);
      Double dummyVal;
      int i=0;
      if(!fs.exists(coordVarPath)) { 
        LOG.error("Path: " + coordVarPath + " does not exists. Bailing");
      }  else { 
        FSDataInputStream in = fs.open(coordVarPath);
        while (in.available() > 0) { 
          dummyVal = in.readDouble();
          in.readChar(); // throw away the /n for each line
          if ("0" == splitTaskID[4]) { 
            LOG.info(i + ":" + dummyVal);
            i++;
          }
        }
      }
    } catch (IOException ioe) { 
      System.out.println(ioe.toString());
    }
    */
    LOG.info("map task " + splitTaskID[4] + " using array keys");

    //System.out.println("cached files: " + localFiles.length + " archives: " + localArchives.length);
    //LOG.info("cached files: " + localFiles.length + " archives: " + localArchives.length);
    try {

      long timer = System.currentTimeMillis();
      //ArrayInt intArray = (ArrayInt)value;
      //E[] dataArray = value;
     
      long elementCount = Utils.calcTotalSize(key.getShape());
      LOG.info("Array Spec has " + elementCount + " elements");

      int[] extractionShape = Utils.getExtractionShape(context.getConfiguration(),
                                                        key.getShape().length);

      LOG.info("Extraction shape is: " + Arrays.toString(extractionShape));
      int[] allOnes = new int[extractionShape.length];
      for( int i=0; i<allOnes.length; i++){
        allOnes[i] = 1;
      }

      ArraySpec arraySpec = new ArraySpec(key.getCorner(), "");
      IntArrayWritable intAW = new IntArrayWritable();
      ArrayList<IntWritable> intWArrayList = new ArrayList<IntWritable>();

      String varName = Utils.getVariableName(context.getConfiguration());       
      ByteBuffer bb = inMVD.getVarDataByName(varName);
      LOG.info("in mapper, corner is: " + 
               Utils.arrayToString(key.getCorner()) + 
               " shape: " + Utils.arrayToString(key.getShape()) + 
               " varName: " + varName + 
               " exShape: " + Arrays.toString(extractionShape) +
               " bb has capacity(): " + bb.capacity());
      DataIterator dataItr = new DataIterator(bb, key.getCorner(),
                                              key.getShape(), extractionShape,
                                              DATATYPESIZE);

      int lowFilter = (int)Utils.getLowThreshold(context.getConfiguration());
      int highFilter = (int)Utils.getHighThreshold(context.getConfiguration());

      int[] tempGroup;
      long totalElements = 0;
      long groupElements = 0;
      int tempInt = Integer.MIN_VALUE;
      IntWritable[] dummyIntWArray;
      long localHitCounter = 0;
      long localMissCounter = 0;
      long globalHitCounter = 0;
      long globalMissCounter = 0;
      int[] tempArray = new int[extractionShape.length];
      while( dataItr.hasMoreGroups() ) { 
        tempGroup = dataItr.getNextGroup();
        intWArrayList.clear();
        groupElements = 0;

        if( tempGroup.length < 4) { 
          System.out.println("dataItr.getNextGroup just returned group: " + 
                             Utils.arrayToString(tempGroup));
        }
        //System.out.println("\tlooping over group " + Utils.arrayToString(tempGroup));
        arraySpec.setVariable(key.getVarName());
        arraySpec.setCorner(tempGroup);


        while( dataItr.groupHasMoreValues() ) { 

          tempInt = dataItr.getNextValueInt();
          if( tempInt > lowFilter && tempInt < highFilter) { 
            intWArrayList.add(new IntWritable(tempInt));
            localHitCounter++;
            //LOG.info("val: " + tempInt + " at: " + arraySpec.toString() + " is valid");
          } else { 
            localMissCounter++;
            //LOG.info("val: " + tempInt + " at: " + arraySpec.toString() + " is NOT valid");
          }
          //intW.set(dataItr.getNextValueInt());

          /*
          if( arraySpec.getCorner().length < 4) { 
            System.out.println("in mapper, getGroupID.length is " + 
            		arraySpec.getCorner().length);
            Thread.dumpStack();
          }
          */

          totalElements++;
          groupElements++;
        }

        // don't output a key/value pair for keys with no values
        if (localHitCounter > 0) { 

          dummyIntWArray = intWArrayList.toArray(new IntWritable[intWArrayList.size()]);
          intAW.set(intWArrayList.toArray(dummyIntWArray));
        
          Utils.mapToLocal(tempGroup, tempArray, arraySpec, extractionShape);
          context.write(arraySpec, intAW, groupElements);
        } 

        globalHitCounter += localHitCounter;
        localHitCounter = 0;
        globalMissCounter += localMissCounter;
        localMissCounter = 0;
      }

      
      timer = System.currentTimeMillis() - timer;

      System.out.println("Just wrote " + totalElements + " for map task " + 
                         splitTaskID[4] + " with key2: " +
                         arraySpec.toString() + 
                         " and it took " + timer + " ms"); 
      context.getCounter(FilterCounters.THRESHOLD_HIT).increment(globalHitCounter);
      context.getCounter(FilterCounters.THRESHOLD_MISS).increment(globalMissCounter);
      LOG.info("global valid: " + globalHitCounter + " invalid: " + globalMissCounter);

      //context.write(groupID, intW);
    } catch ( Exception e ) {
      System.out.println("Caught an exception in FilterMapper.map()" + e.toString() );
      e.printStackTrace();
    }
  }
}
